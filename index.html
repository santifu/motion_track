<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Real-time Object Tracking - WebSocket</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js"></script>
    <script src="https://unpkg.com/ml5@0.6.1/dist/ml5.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 20px;
            background-color: #f0f0f0;
        }
        #p5-canvas-container {
            border: 1px solid #ccc;
            margin-bottom: 20px;
            background-color: #fff;
        }
        #controls {
            background-color: #fff;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            width: 640px;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        .control-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        .checkbox-container {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            max-height: 150px;
            overflow-y: auto;
            padding: 5px 0;
            border: 1px solid #eee;
            border-radius: 4px;
            background-color: #f9f9f9;
        }
        .checkbox-container label {
            display: flex;
            align-items: center;
            gap: 5px;
            margin-right: 10px;
        }
        button {
            padding: 10px 15px;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            transition: background-color 0.2s ease;
        }
        button:hover {
            background-color: #0056b3;
        }
        button:disabled {
            background-color: #6c757d;
            cursor: not-allowed;
        }
        .websocket-group {
            border: 2px solid #007bff;
            border-radius: 8px;
            padding: 15px;
            background-color: #f8f9fa;
        }
        .status-indicator {
            display: inline-block;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-right: 8px;
        }
        .status-connected {
            background-color: #28a745;
        }
        .status-disconnected {
            background-color: #dc3545;
        }
        .status-connecting {
            background-color: #ffc107;
        }
        .coordinates-display {
            background-color: #e9ecef;
            padding: 10px;
            border-radius: 4px;
            font-family: monospace;
            font-size: 12px;
            max-height: 100px;
            overflow-y: auto;
        }
        .input-group {
            display: flex;
            gap: 10px;
            align-items: center;
        }
        .input-group input {
            flex: 1;
            padding: 8px;
            border: 1px solid #ccc;
            border-radius: 4px;
        }
    </style>
</head>
<body>
    <h1>Real-time Object Tracking - WebSocket</h1>
    <div id="p5-canvas-container"></div>
    <div id="controls">
        <!-- WebSocket Controls -->
        <div class="control-group websocket-group">
            <h3>WebSocket Connection to Blender</h3>
            <div class="input-group">
                <label for="websocketUrl">WebSocket URL:</label>
                <input type="text" id="websocketUrl" value="ws://localhost:8765" placeholder="ws://localhost:8765">
                <button id="connectBtn">Connect</button>
                <button id="disconnectBtn" disabled>Disconnect</button>
            </div>
            <div id="connectionStatus">
                <span class="status-indicator status-disconnected"></span>
                <span id="statusText">Disconnected</span>
            </div>
            <div class="control-group">
                <label>Last coordinates sent:</label>
                <div id="coordinatesDisplay" class="coordinates-display">No data sent yet</div>
            </div>
        </div>

        <!-- Coordinate Mapping Controls -->
        <div class="control-group">
            <h3>Coordinate Mapping</h3>
            <div class="input-group">
                <label for="scaleX">Scale X:</label>
                <input type="number" id="scaleX" value="0.01" step="0.001" min="0.001" max="1">
                <label for="scaleY">Scale Y:</label>
                <input type="number" id="scaleY" value="0.01" step="0.001" min="0.001" max="1">
                <label for="scaleZ">Scale Z:</label>
                <input type="number" id="scaleZ" value="0.01" step="0.001" min="0.001" max="1">
            </div>
            <div class="input-group">
                <label for="offsetX">Offset X:</label>
                <input type="number" id="offsetX" value="0" step="0.1">
                <label for="offsetY">Offset Y:</label>
                <input type="number" id="offsetY" value="0" step="0.1">
                <label for="offsetZ">Offset Z:</label>
                <input type="number" id="offsetZ" value="0" step="0.1">
            </div>
        </div>

        <!-- Original Controls -->
        <div class="control-group">
            <label for="pointSizeSlider">Trajectory Point Size:</label>
            <input type="range" id="pointSizeSlider" min="1" max="60" value="5" step="1">
            <span id="pointSizeValue">5</span>
        </div>

        <div class="control-group">
            <p>Select objects to track:</p>
            <div id="checkboxes-container" class="checkbox-container">
                <p>Loading model and awaiting detections...</p>
            </div>
        </div>

        <div class="control-group">
            <button id="saveTrajectoryBtn">Save Trajectory (PNG)</button>
            <button id="clearTrajectoryBtn">Clear Trajectory</button>
        </div>
    </div>

    <script>
        let objectDetector;
        let video;
        let detections = [];
        let trajectoryLayer;
        let pointSizeSliderHTML;
        let pointSizeValueSpan;
        let selectedLabels = {};
        let labelCheckboxes = {};
        let checkboxesContainer;

        // WebSocket variables
        let websocket = null;
        let isConnected = false;
        let connectionStatus;
        let statusText;
        let coordinatesDisplay;

        // Coordinate mapping variables
        let scaleX, scaleY, scaleZ;
        let offsetX, offsetY, offsetZ;

        function setup() {
            let canvas = createCanvas(640, 480);
            canvas.parent('p5-canvas-container');

            video = createCapture(VIDEO);
            video.size(640, 480);
            video.hide();

            trajectoryLayer = createGraphics(640, 480);
            trajectoryLayer.clear();

            // Get references to HTML elements
            pointSizeSliderHTML = document.getElementById('pointSizeSlider');
            pointSizeValueSpan = document.getElementById('pointSizeValue');
            checkboxesContainer = document.getElementById('checkboxes-container');
            connectionStatus = document.querySelector('.status-indicator');
            statusText = document.getElementById('statusText');
            coordinatesDisplay = document.getElementById('coordinatesDisplay');

            // Get coordinate mapping controls
            scaleX = document.getElementById('scaleX');
            scaleY = document.getElementById('scaleY');
            scaleZ = document.getElementById('scaleZ');
            offsetX = document.getElementById('offsetX');
            offsetY = document.getElementById('offsetY');
            offsetZ = document.getElementById('offsetZ');

            // Set up event listeners
            pointSizeSliderHTML.addEventListener('input', () => {
                pointSizeValueSpan.innerText = pointSizeSliderHTML.value;
            });

            document.getElementById('connectBtn').addEventListener('click', connectWebSocket);
            document.getElementById('disconnectBtn').addEventListener('click', disconnectWebSocket);
            document.getElementById('saveTrajectoryBtn').addEventListener('click', () => {
                trajectoryLayer.save('trajectory.png');
            });
            document.getElementById('clearTrajectoryBtn').addEventListener('click', () => {
                trajectoryLayer.clear();
                console.log('Trajectory cleared.');
            });

            // Load the pre-trained COCO-SSD object detection model
            objectDetector = ml5.objectDetector('cocossd', modelReady);
        }

        function connectWebSocket() {
            const url = document.getElementById('websocketUrl').value;
            
            if (websocket && websocket.readyState === WebSocket.OPEN) {
                console.log('Already connected');
                return;
            }

            try {
                websocket = new WebSocket(url);
                updateConnectionStatus('connecting', 'Connecting...');
                
                websocket.onopen = function(event) {
                    console.log('WebSocket connected');
                    isConnected = true;
                    updateConnectionStatus('connected', 'Connected');
                    document.getElementById('connectBtn').disabled = true;
                    document.getElementById('disconnectBtn').disabled = false;
                };

                websocket.onclose = function(event) {
                    console.log('WebSocket disconnected');
                    isConnected = false;
                    updateConnectionStatus('disconnected', 'Disconnected');
                    document.getElementById('connectBtn').disabled = false;
                    document.getElementById('disconnectBtn').disabled = true;
                };

                websocket.onerror = function(error) {
                    console.error('WebSocket error:', error);
                    updateConnectionStatus('disconnected', 'Error connecting');
                };

                websocket.onmessage = function(event) {
                    console.log('Received from Blender:', event.data);
                };

            } catch (error) {
                console.error('Failed to create WebSocket:', error);
                updateConnectionStatus('disconnected', 'Connection failed');
            }
        }

        function disconnectWebSocket() {
            if (websocket) {
                websocket.close();
                websocket = null;
            }
        }

        function updateConnectionStatus(status, text) {
            connectionStatus.className = `status-indicator status-${status}`;
            statusText.textContent = text;
        }

        function sendCoordinatesToBlender(objectData) {
            if (!isConnected || !websocket) return;

            // Convert 2D coordinates to 3D with scaling and offset
            const x = (objectData.x * parseFloat(scaleX.value)) + parseFloat(offsetX.value);
            const y = (objectData.y * parseFloat(scaleY.value)) + parseFloat(offsetY.value);
            const z = (objectData.confidence * parseFloat(scaleZ.value)) + parseFloat(offsetZ.value);

            const coordinateData = {
                timestamp: Date.now(),
                label: objectData.label,
                confidence: objectData.confidence,
                coordinates: {
                    x: x,
                    y: y,
                    z: z
                },
                original_coordinates: {
                    x: objectData.x,
                    y: objectData.y,
                    width: objectData.width,
                    height: objectData.height
                }
            };

            try {
                websocket.send(JSON.stringify(coordinateData));
                
                // Update display
                coordinatesDisplay.innerHTML = `
                    <strong>${objectData.label}</strong><br>
                    X: ${x.toFixed(3)}, Y: ${y.toFixed(3)}, Z: ${z.toFixed(3)}<br>
                    Confidence: ${(objectData.confidence * 100).toFixed(1)}%<br>
                    Time: ${new Date().toLocaleTimeString()}
                `;
                
                console.log('Sent to Blender:', coordinateData);
            } catch (error) {
                console.error('Error sending data:', error);
            }
        }

        function modelReady() {
            console.log('Model loaded.');
            checkboxesContainer.innerHTML = '';
            video.elt.addEventListener('loadeddata', () => {
                console.log('Video ready. Starting detection...');
                detectObjects();
            });
        }

        function detectObjects() {
            objectDetector.detect(video, gotResults);
        }

        function gotResults(error, results) {
            if (error) {
                console.error(error);
                return;
            }
            detections = results;
            updateLabelCheckboxes(detections);
            detectObjects();
        }

        function updateLabelCheckboxes(currentDetections) {
            for (let i = 0; i < currentDetections.length; i++) {
                let obj = currentDetections[i];
                if (!(obj.label in labelCheckboxes)) {
                    addLabelCheckbox(obj.label);
                }
            }
        }

        function addLabelCheckbox(label) {
            let labelDiv = document.createElement('label');
            let checkboxInput = document.createElement('input');
            checkboxInput.type = 'checkbox';
            checkboxInput.value = label;
            checkboxInput.id = 'checkbox-' + label.replace(/\s+/g, '-');

            let spanText = document.createElement('span');
            spanText.innerText = label;

            labelDiv.appendChild(checkboxInput);
            labelDiv.appendChild(spanText);
            checkboxesContainer.appendChild(labelDiv);

            labelCheckboxes[label] = checkboxInput;
            selectedLabels[label] = false;

            checkboxInput.addEventListener('change', (event) => {
                selectedLabels[label] = event.target.checked;
                console.log(selectedLabels);
            });
        }

        function draw() {
            push();
            translate(width, 0);
            scale(-1, 1);
            image(video, 0, 0);
            pop();

            for (let i = 0; i < detections.length; i++) {
                let obj = detections[i];

                stroke(0, 255, 0);
                strokeWeight(2);
                noFill();
                rect(obj.x, obj.y, obj.width, obj.height);

                noStroke();
                fill(255);
                textSize(16);
                text(obj.label + ' ' + nfc(obj.confidence * 100, 2) + '%', obj.x + 5, obj.y + 15);

                if (selectedLabels[obj.label]) {
                    let cx = obj.x + obj.width / 2;
                    let cy = obj.y + obj.height / 2;
                    let flippedCx = width - cx;

                    // Send coordinates to Blender
                    sendCoordinatesToBlender({
                        label: obj.label,
                        confidence: obj.confidence,
                        x: flippedCx,
                        y: cy,
                        width: obj.width,
                        height: obj.height
                    });

                    let pointSize = parseInt(pointSizeSliderHTML.value);
                    trajectoryLayer.noStroke();
                    trajectoryLayer.fill(255, 255, 255, 150);
                    trajectoryLayer.ellipse(flippedCx, cy, pointSize, pointSize);
                }
            }

            image(trajectoryLayer, 0, 0);
        }

        function keyPressed() {
            if (key === 't' || key === 'T') {
                trajectoryLayer.save('trajectory.png');
            }
            if (key === 'c' || key === 'C') {
                trajectoryLayer.clear();
                console.log('Trajectory cleared.');
            }
        }
    </script>
</body>
</html>