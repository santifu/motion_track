<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>From Bits To Atoms - Canny Edge Detection</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js"></script>
    <script src="jsfeat.min.js"></script> 
    
    <style>
        body {
            font-family: Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 20px;
            background-color: #f0f0f0;
        }
        #fbtaSketch {
            border: 1px solid #ccc;
            margin-bottom: 20px;
            background-color: #fff;
        }
        #controls {
            background-color: #fff;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            width: 640px; /* Match canvas width */
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        .control-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        .control-group label {
            font-weight: bold;
        }
        .control-group span {
            font-size: 0.9em;
            color: #555;
        }
        input[type="range"] {
            width: 100%;
        }
        button {
            padding: 10px 15px;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            transition: background-color 0.2s ease;
        }
        button:hover {
            background-color: #0056b3;
        }
    </style>
</head>
<body>
    <h1>From Bits To Atoms - Canny Edge Detection</h1>
    <div id="fbtaSketch"></div>
    <div id="controls">
        <div class="control-group">
            <label for="blurSize">Blur Size:</label>
            <input type="range" id="blurSize" min="0" max="100" value="50">
            <span id="blurValue">50</span>
        </div>
        <div class="control-group">
            <label for="lowThreshold">Low Threshold:</label>
            <input type="range" id="lowThreshold" min="0" max="100" value="20">
            <span id="lowThreshValue">20</span>
        </div>
        <div class="control-group">
            <label for="highThreshold">High Threshold:</label>
            <input type="range" id="highThreshold" min="0" max="100" value="70">
            <span id="highThreshValue">70</span>
        </div>
        <button onclick="doScan()">Save Edge Image (PNG)</button>
    </div>

    <script>
        // Global variables for P5.js and jsfeat
        var capture;
        var buffer; // jsfeat buffer for grayscale image
        var result; // P5.Image to store jsfeat's output
        var w = 640, h = 480; // Default dimensions

        // References to HTML slider elements and their value displays
        let blurSizeSlider, lowThresholdSlider, highThresholdSlider;
        let blurValueSpan, lowThreshValueSpan, highThreshValueSpan;

        function setup() {
            // Adjust dimensions and camera constraints for mobile devices
            if (/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)) {
                w = 360;
                h = 270;
                var constraints = {
                    audio: false,
                    video: {
                        facingMode: {
                            exact: "environment" // Prefer back camera on mobile
                        }
                    }
                };
                capture = createCapture(constraints);
            } else {
                capture = createCapture(VIDEO); // Default camera for desktop
            }

            // Create P5.js canvas and attach it to the 'fbtaSketch' div
            var myCanvas = createCanvas(w, h, SVG); // Use SVG renderer
            myCanvas.parent("fbtaSketch");

            // Set video size to match canvas and hide the raw video element
            capture.size(w, h);
            capture.hide();

            // Initialize jsfeat buffer for grayscale processing
            buffer = new jsfeat.matrix_t(w, h, jsfeat.U8C1_t);

            // Get references to HTML slider elements and their value displays
            blurSizeSlider = document.getElementById('blurSize');
            lowThresholdSlider = document.getElementById('lowThreshold');
            highThresholdSlider = document.getElementById('highThreshold');

            blurValueSpan = document.getElementById('blurValue');
            lowThreshValueSpan = document.getElementById('lowThreshValue');
            highThreshValueSpan = document.getElementById('highThreshValue');

            // Update displayed values when sliders are moved
            blurSizeSlider.addEventListener('input', () => blurValueSpan.innerText = blurSizeSlider.value);
            lowThresholdSlider.addEventListener('input', () => lowThreshValueSpan.innerText = lowThresholdSlider.value);
            highThresholdSlider.addEventListener('input', () => highThreshValueSpan.innerText = highThresholdSlider.value);

            // Initial update of slider values
            blurValueSpan.innerText = blurSizeSlider.value;
            lowThreshValueSpan.innerText = lowThresholdSlider.value;
            highThreshValueSpan.innerText = highThresholdSlider.value;
        }

        function draw() {
            // Set stroke for any lines (not directly used for the edge image, but good practice)
            stroke('red');
            strokeWeight(2);

            // Load pixels from the video capture
            capture.loadPixels();

            // Only process if video pixels are available
            if (capture.pixels.length > 0) {
                // Get slider values and map them to jsfeat's expected ranges
                let blurSize = parseInt(blurSizeSlider.value);
                let lowThreshold = parseInt(lowThresholdSlider.value);
                let highThreshold = parseInt(highThresholdSlider.value);
                
                // Map slider values for blur and thresholds
                // blurSize needs to be an odd integer, and usually positive. 
                // A value of 0 from slider maps to 1 for jsfeat, max 100 maps to 12 (approx)
                blurSize = map(blurSize, 0, 100, 1, 12); 
                // Ensure blurSize is an odd number for jsfeat.gaussian_blur
                if (blurSize % 2 === 0) blurSize++; 

                lowThreshold = map(lowThreshold, 0, 100, 0, 255);
                highThreshold = map(highThreshold, 0, 100, 0, 255);

                // --- jsfeat image processing steps ---
                // 1. Convert video pixels to grayscale jsfeat buffer
                jsfeat.imgproc.grayscale(capture.pixels, w, h, buffer);
                
                // 2. Apply Gaussian blur
                jsfeat.imgproc.gaussian_blur(buffer, buffer, blurSize, 0);
                
                // 3. Perform Canny edge detection
                jsfeat.imgproc.canny(buffer, buffer, lowThreshold, highThreshold);

                // Convert jsfeat buffer back to P5.Image
                result = jsfeatToP5(buffer, result);
                
                // Invert the colors of the result image (edges will be black on white, or vice-versa)
                result.loadPixels();
                for (let y = 0; y < result.height; y++) {
                    for (let x = 0; x < result.width; x++) {
                        const index = (y * result.width + x) * 4; // RGBA pixel index
                        const r = result.pixels[index + 0];
                        const g = result.pixels[index + 1];
                        const b = result.pixels[index + 2];
                        
                        // Invert RGB values
                        result.pixels[index + 0] = 255 - r;
                        result.pixels[index + 1] = 255 - g;
                        result.pixels[index + 2] = 255 - b;
                        // Alpha remains 255
                    }
                }
                result.updatePixels(); // Apply pixel changes

                // Display the processed image on the canvas
                image(result, 0, 0, w, h);
            }
        }

        // Function to save the current edge-detected image
        function doScan() {
            print("Screenshot!");
            save(result, 'fbta_' + int(random(1000)) + '_falabbcn.png');
        }

        // Optional: Keyboard shortcut for saving the image
        function keyPressed() {
            if (keyCode === DOWN_ARROW) {
                doScan();
            }
        }

        // Helper function to convert a grayscale jsfeat image buffer to a P5.Image (RGBA)
        function jsfeatToP5(src, dst) {
            // Create new P5.Image if 'dst' is not provided or has wrong dimensions
            if (!dst || dst.width !== src.cols || dst.height !== src.rows) {
                dst = createImage(src.cols, src.rows);
            }
            
            let n = src.data.length; // Number of pixels in jsfeat buffer
            dst.loadPixels(); // Load pixels array for manipulation
            
            let srcData = src.data; // jsfeat's 8-bit grayscale data
            let dstData = dst.pixels; // P5.js's RGBA pixel array
            
            // Iterate through srcData and populate dstData
            for (let i = 0, j = 0; i < n; i++) {
                let cur = srcData[i]; // Grayscale value
                dstData[j++] = cur; // Red channel
                dstData[j++] = cur; // Green channel
                dstData[j++] = cur; // Blue channel
                dstData[j++] = 255; // Alpha channel (fully opaque)
            }
            dst.updatePixels(); // Apply pixel changes to the image
            return dst;
        }
    </script>
</body>
</html>
