<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Real-time Object Tracking (Video Upload)</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.4/p5.min.js"></script> 
    <script src="https://unpkg.com/ml5@0.6.1/dist/ml5.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 20px;
            background-color: #f0f0f0;
        }
        h1 {
            color: #333;
            margin-bottom: 20px;
        }
        #p5-canvas-container {
            border: 1px solid #ccc;
            margin-bottom: 20px;
            background-color: #fff;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 240px; /* Altura mínima para que se vea el mensaje de carga */
        }
        canvas {
            max-width: 100%;
            height: auto;
            display: block; /* Eliminar espacio extra debajo del canvas */
        }
        #controls {
            background-color: #fff;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            width: 90%; 
            max-width: 640px; 
            display: flex;
            flex-direction: column;
            gap: 15px;
            align-items: flex-start;
        }
        .control-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
            width: 100%;
        }
        .control-group label {
            font-weight: bold;
            color: #333;
            margin-bottom: 5px;
        }
        input[type="file"] {
            padding: 8px;
            border-radius: 4px;
            border: 1px solid #ccc;
            width: 100%;
            font-size: 16px;
            box-sizing: border-box;
            background-color: #e9e9e9;
        }
        input[type="range"] {
            padding: 8px;
            border-radius: 4px;
            border: 1px solid #ccc;
            width: 100%;
            font-size: 16px;
            box-sizing: border-box;
        }
        .checkbox-container {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            max-height: 150px;
            overflow-y: auto;
            padding: 5px 0;
            border: 1px solid #eee;
            border-radius: 4px;
            background-color: #f9f9f9;
        }
        .checkbox-container label {
            display: flex;
            align-items: center;
            gap: 5px;
            margin-right: 10px;
            font-weight: normal;
        }
        button {
            padding: 10px 15px;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            transition: background-color 0.2s ease;
            width: 100%;
            box-sizing: border-box;
        }
        button:hover {
            background-color: #0056b3;
        }
        #status-message {
            color: #555;
            font-style: italic;
            width: 100%;
            text-align: center;
        }
    </style>
</head>
<body>
    <h1>Real-time Object Tracking (Video Upload)</h1>
    <div id="p5-canvas-container"></div>
    <div id="controls">
        <div class="control-group">
            <label for="videoUpload">Upload Video File:</label>
            <input type="file" id="videoUpload" accept="video/mp4,video/webm">
        </div>

        <div class="control-group">
            <label for="pointSizeSlider">Trajectory Point Size:</label>
            <input type="range" id="pointSizeSlider" min="1" max="60" value="5" step="1">
            <span id="pointSizeValue">5</span>
        </div>

        <div class="control-group">
            <p>Select objects to track:</p>
            <div id="checkboxes-container" class="checkbox-container">
                <p>Upload a video to start detection...</p>
            </div>
        </div>

        <p id="status-message">Waiting for video upload...</p>

        <div class="control-group">
            <button id="saveTrajectoryBtn">Save Trajectory (PNG)</button>
            <button id="clearTrajectoryBtn">Clear Trajectory</button>
        </div>
    </div>

    <script>
        let objectDetector;
        let videoElement; // Direct HTML video element
        let p5Video;      // p5.Video object created from videoElement
        let detections = [];
        let trajectoryLayer;
        let pointSizeSliderHTML;
        let pointSizeValueSpan;
        let selectedLabels = {};
        let labelCheckboxes = {};
        let checkboxesContainer;
        let videoUploadInput; // Reference to the file input element
        let statusMessageElem;

        let canvasWidth;
        let canvasHeight;

        function setup() {
            // Calculate canvas size for responsiveness, default if no video yet
            canvasWidth = Math.min(640, windowWidth * 0.9);
            canvasHeight = canvasWidth * (480 / 640); // Initial 4:3 aspect ratio

            let canvas = createCanvas(canvasWidth, canvasHeight);
            canvas.parent('p5-canvas-container');

            trajectoryLayer = createGraphics(canvasWidth, canvasHeight);
            trajectoryLayer.clear();

            pointSizeSliderHTML = document.getElementById('pointSizeSlider');
            pointSizeValueSpan = document.getElementById('pointSizeValue');
            checkboxesContainer = document.getElementById('checkboxes-container');
            videoUploadInput = document.getElementById('videoUpload');
            statusMessageElem = select('#status-message');

            pointSizeSliderHTML.addEventListener('input', () => {
                pointSizeValueSpan.innerText = pointSizeSliderHTML.value;
            });
            document.getElementById('saveTrajectoryBtn').addEventListener('click', () => {
                // To save the full canvas (video frame + detections + trajectory)
                saveCanvas('object_trajectory', 'png'); 
            });
            document.getElementById('clearTrajectoryBtn').addEventListener('click', () => {
                trajectoryLayer.clear();
                console.log('Trajectory cleared.');
            });

            // Listen for file selection
            videoUploadInput.addEventListener('change', handleVideoUpload);

            statusMessageElem.html('Cargando modelo COCO-SSD...');
            // Load the object detection model once at setup
            objectDetector = ml5.objectDetector('cocossd', modelLoaded);
        }

        function modelLoaded() {
            statusMessageElem.html('Modelo COCO-SSD cargado. Por favor, sube un archivo de video.');
            console.log('Model loaded.');
        }

        function handleVideoUpload(event) {
            const file = event.target.files[0];
            if (file) {
                if (file.type.startsWith('video/')) {
                    statusMessageElem.html('Video seleccionado. Preparando...');
                    // Create an HTML5 video element
                    videoElement = document.createElement('video');
                    videoElement.src = URL.createObjectURL(file);
                    videoElement.controls = true; // Show video controls
                    videoElement.loop = true;     // Loop the video
                    videoElement.muted = true;    // Mute by default for autoplay on some browsers

                    // When video metadata is loaded, get its actual dimensions
                    videoElement.addEventListener('loadedmetadata', () => {
                        // Adjust canvas size to match video aspect ratio, capping at max width
                        canvasWidth = Math.min(640, windowWidth * 0.9);
                        canvasHeight = canvasWidth * (videoElement.videoHeight / videoElement.videoWidth);
                        resizeCanvas(canvasWidth, canvasHeight);
                        trajectoryLayer = createGraphics(canvasWidth, canvasHeight); // Recreate trajectory layer
                        trajectoryLayer.clear();

                        p5Video = new p5.Video(videoElement); // Create p5.Video from HTML video element
                        p5Video.size(canvasWidth, canvasHeight);
                        p5Video.hide(); // Hide the actual HTML video element

                        videoElement.play().then(() => {
                            statusMessageElem.html('Video reproduciéndose. Iniciando detección...');
                            detectObjects(); // Start detection once video starts playing
                        }).catch(error => {
                            statusMessageElem.html('Error al reproducir el video: ' + error.message);
                            console.error('Error playing video:', error);
                        });
                    });

                    // Add video element to the DOM (hidden by p5.Video.hide()) if you need to inspect it
                    // document.body.appendChild(videoElement); 

                } else {
                    statusMessageElem.html('Por favor, selecciona un archivo de video (MP4/WebM).');
                    alert('Please select a video file (MP4/WebM).');
                }
            }
        }

        function detectObjects() {
            if (p5Video && p5Video.elt.readyState >= 2 && objectDetector) { // Check if video is loaded and detector is ready
                objectDetector.detect(p5Video, gotResults);
            } else {
                // If video is not ready or detector not loaded, try again in a bit
                setTimeout(detectObjects, 100); 
            }
        }

        function gotResults(error, results) {
            if (error) {
                console.error(error);
                // Continue trying to detect even if there's a temporary error
                if (p5Video && p5Video.elt.readyState >= 2) {
                    detectObjects(); 
                }
                return;
            }
            detections = results;
            updateLabelCheckboxes(detections);
            
            // Only continue detection if video is still playing
            if (p5Video && !p5Video.elt.paused) {
                 detectObjects(); // Loop detection
            } else {
                statusMessageElem.html('Video pausado/terminado. Detección detenida.');
            }
        }

        function updateLabelCheckboxes(currentDetections) {
            // Collect all unique labels from current detections
            let currentLabels = new Set();
            for (let i = 0; i < currentDetections.length; i++) {
                currentLabels.add(currentDetections[i].label);
            }

            // Add new checkboxes for newly detected labels
            currentLabels.forEach(label => {
                if (!(label in labelCheckboxes)) {
                    addLabelCheckbox(label);
                }
            });

            // (Optional) Remove checkboxes for labels that are no longer detected
            // This is more complex as it requires tracking which checkboxes are active and removing them.
            // For simplicity, we'll keep previously created checkboxes.
        }

        function addLabelCheckbox(label) {
            let labelDiv = document.createElement('label');
            let checkboxInput = document.createElement('input');
            checkboxInput.type = 'checkbox';
            checkboxInput.value = label;
            checkboxInput.id = 'checkbox-' + label.replace(/\s+/g, '-'); 

            let spanText = document.createElement('span');
            spanText.innerText = label;

            labelDiv.appendChild(checkboxInput);
            labelDiv.appendChild(spanText);
            checkboxesContainer.appendChild(labelDiv); 

            labelCheckboxes[label] = checkboxInput;
            selectedLabels[label] = false; // Initialize selection state to false

            checkboxInput.addEventListener('change', (event) => {
                selectedLabels[label] = event.target.checked; 
                console.log(selectedLabels); 
            });
            checkboxesContainer.innerHTML = ''; // Clear loading message
        }

        function draw() {
            // Draw a background before the video, so messages are visible if video isn't loaded
            background(50); 

            if (p5Video && p5Video.elt.readyState >= 2) {
                // IMPORTANT: When drawing a pre-loaded video, you usually don't flip it
                // unless the video itself is recorded in a "mirror" way.
                // For simplicity, we'll assume the uploaded video doesn't need flipping
                // or that the flipping logic for live camera is removed for consistency.
                // If you *want* it mirrored, you'd apply the push/translate/scale.
                // For now, drawing directly.
                image(p5Video, 0, 0, width, height); 
            } else {
                fill(255);
                textAlign(CENTER, CENTER);
                textSize(20);
                text('Sube un video para empezar...', width / 2, height / 2);
            }

            // Draw bounding boxes and labels for all detected objects
            for (let i = 0; i < detections.length; i++) {
                let obj = detections[i];

                stroke(0, 255, 0); 
                strokeWeight(2);
                noFill();
                rect(obj.x, obj.y, obj.width, obj.height);

                noStroke();
                fill(255); 
                textSize(16);
                text(obj.label + ' ' + nfc(obj.confidence * 100, 2) + '%', obj.x + 5, obj.y + 15);

                // Draw trajectories only for selected labels
                if (selectedLabels[obj.label]) {
                    let cx = obj.x + obj.width / 2;
                    let cy = obj.y + obj.height / 2;

                    // For uploaded video, no need to flip X coordinate for trajectory dots
                    // unless you explicitly flipped the video playback.
                    let pointSize = parseInt(pointSizeSliderHTML.value);

                    trajectoryLayer.noStroke();
                    trajectoryLayer.fill(255, 255, 255, 150); 
                    trajectoryLayer.ellipse(cx, cy, pointSize, pointSize);
                }
            }

            // Display the accumulated trajectory layer on top of the video frame
            image(trajectoryLayer, 0, 0);
        }

        // No keyPressed needed since actions are via buttons now
    </script>
</body>
</html>
