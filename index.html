<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Contour-like Tracking with P5.js and ml5.js</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js"></script>
    <script src="https://unpkg.com/ml5@0.6.1/dist/ml5.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 20px;
            background-color: #f0f0f0;
        }
        #p5-canvas-container {
            border: 1px solid #ccc;
            margin-bottom: 20px;
            background-color: #fff;
        }
        #controls {
            background-color: #fff;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            width: 640px; /* Match canvas width */
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        .control-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        .checkbox-container {
            display: flex;
            flex-wrap: wrap; /* Allow checkboxes to wrap */
            gap: 10px;
            max-height: 150px; /* Limit height and add scroll if many checkboxes */
            overflow-y: auto;
            padding: 5px 0;
            border: 1px solid #eee;
            border-radius: 4px;
            background-color: #f9f9f9;
        }
        .checkbox-container label {
            display: flex;
            align-items: center;
            gap: 5px;
            margin-right: 10px; /* Spacing between checkboxes */
        }
        button {
            padding: 10px 15px;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            transition: background-color 0.2s ease;
        }
        button:hover {
            background-color: #0056b3;
        }
    </style>
</head>
<body>
    <h1>Contour-like Tracking with Gaussian Accumulation</h1>
    <div id="p5-canvas-container"></div>
    <div id="controls">
        <div class="control-group">
            <label for="kernelSizeSlider">Gaussian Kernel Size (pixels):</label>
            <input type="range" id="kernelSizeSlider" min="5" max="51" value="15" step="2">
            <span id="kernelSizeValue">15</span>
        </div>
        <div class="control-group">
            <label for="sigmaSlider">Gaussian Sigma (blur amount):</label>
            <input type="range" id="sigmaSlider" min="0.5" max="10" value="4" step="0.5">
            <span id="sigmaValue">4</span>
        </div>
        <div class="control-group">
            <label for="overlayAlphaSlider">Accumulation Overlay Opacity:</label>
            <input type="range" id="overlayAlphaSlider" min="0" max="100" value="30" step="1">
            <span id="overlayAlphaValue">30%</span>
        </div>

        <div class="control-group">
            <p>Select objects to track (based on bounding box center):</p>
            <div id="checkboxes-container" class="checkbox-container">
                <p>Loading model and awaiting detections...</p>
            </div>
        </div>

        <div class="control-group">
            <button id="saveAccumulationBtn">Save Accumulated Pattern (PNG)</button>
            <button id="clearAccumulationBtn">Clear Accumulated Pattern</button>
        </div>
    </div>

    <script>
        let objectDetector;
        let video;
        let detections = [];
        let accumulatorLayer; // This will act like your Python 'accumulator'
        let kernelSizeSliderHTML;
        let kernelSizeValueSpan;
        let sigmaSliderHTML;
        let sigmaValueSpan;
        let overlayAlphaSliderHTML;
        let overlayAlphaValueSpan;

        let selectedLabels = {};
        let labelCheckboxes = {};
        let checkboxesContainer;

        // --- Gaussian Kernel Functions (Adapted from Python to P5.js Canvas) ---
        // This kernel is applied to the accumulatorLayer using image data manipulation.
        let gaussianKernelData = []; // To store the 1D or 2D kernel values
        let currentKernelSize = 15;
        let currentSigma = 4;

        function generateGaussianKernel(size, sigma) {
            let kernel = [];
            let sum = 0;
            let half = (size - 1) / 2;

            for (let y = 0; y < size; y++) {
                let row = [];
                for (let x = 0; x < size; x++) {
                    let dx = x - half;
                    let dy = y - half;
                    let value = Math.exp(-0.5 * (dx * dx + dy * dy) / (sigma * sigma));
                    row.push(value);
                    sum += value;
                }
                kernel.push(row);
            }

            // Normalize the kernel
            for (let y = 0; y < size; y++) {
                for (let x = 0; x < size; x++) {
                    kernel[y][x] /= sum;
                }
            }
            return kernel;
        }

        function addGaussianPointToLayer(layer, kernel, center_x, center_y) {
            let k_size = kernel.length;
            let half = Math.floor(k_size / 2);

            // Get the pixels of the layer to manipulate directly
            layer.loadPixels();

            for (let ky = 0; ky < k_size; ky++) {
                for (let kx = 0; kx < k_size; kx++) {
                    let pixelX = center_x + (kx - half);
                    let pixelY = center_y + (ky - half);

                    // Check bounds
                    if (pixelX >= 0 && pixelX < layer.width && pixelY >= 0 && pixelY < layer.height) {
                        let index = (pixelX + pixelY * layer.width) * 4; // RGBA

                        // Add kernel value to the red channel (or any channel, we'll display it as grayscale)
                        // Scale the kernel value to a visible range (e.g., 0-255).
                        // You might need to adjust this scaling depending on how "bright" you want the points.
                        // We'll let the normalization handle overall brightness later.
                        let currentRed = layer.pixels[index];
                        let newValue = currentRed + (kernel[ky][kx] * 50); // Multiply by a factor for visibility

                        layer.pixels[index] = Math.min(255, newValue); // Cap at 255
                        // Keep other channels and alpha for now, or set them to match red for grayscale
                        layer.pixels[index + 1] = layer.pixels[index]; // Green
                        layer.pixels[index + 2] = layer.pixels[index]; // Blue
                        layer.pixels[index + 3] = 255; // Alpha (fully opaque dot parts)
                    }
                }
            }
            layer.updatePixels();
        }
        // --- End Gaussian Kernel Functions ---

        function setup() {
            let canvas = createCanvas(640, 480);
            canvas.parent('p5-canvas-container');

            video = createCapture(VIDEO);
            video.size(640, 480);
            video.hide();

            accumulatorLayer = createGraphics(640, 480);
            accumulatorLayer.background(0); // Start with black background (represents 0 accumulation)

            // Get references to HTML elements
            kernelSizeSliderHTML = document.getElementById('kernelSizeSlider');
            kernelSizeValueSpan = document.getElementById('kernelSizeValue');
            sigmaSliderHTML = document.getElementById('sigmaSlider');
            sigmaValueSpan = document.getElementById('sigmaValue');
            overlayAlphaSliderHTML = document.getElementById('overlayAlphaSlider');
            overlayAlphaValueSpan = document.getElementById('overlayAlphaValue');
            checkboxesContainer = document.getElementById('checkboxes-container');

            // Initialize kernel and update spans
            currentKernelSize = parseInt(kernelSizeSliderHTML.value);
            currentSigma = parseFloat(sigmaSliderHTML.value);
            gaussianKernelData = generateGaussianKernel(currentKernelSize, currentSigma);
            kernelSizeValueSpan.innerText = currentKernelSize;
            sigmaValueSpan.innerText = currentSigma;
            overlayAlphaValueSpan.innerText = overlayAlphaSliderHTML.value + '%';

            // Update kernel parameters when sliders move
            kernelSizeSliderHTML.addEventListener('input', () => {
                currentKernelSize = parseInt(kernelSizeSliderHTML.value);
                // Ensure kernel size is odd for proper centering
                if (currentKernelSize % 2 === 0) currentKernelSize += 1;
                kernelSizeSliderHTML.value = currentKernelSize; // Update slider if adjusted
                kernelSizeValueSpan.innerText = currentKernelSize;
                gaussianKernelData = generateGaussianKernel(currentKernelSize, currentSigma);
            });
            sigmaSliderHTML.addEventListener('input', () => {
                currentSigma = parseFloat(sigmaSliderHTML.value);
                sigmaValueSpan.innerText = currentSigma;
                gaussianKernelData = generateGaussianKernel(currentKernelSize, currentSigma);
            });
            overlayAlphaSliderHTML.addEventListener('input', () => {
                overlayAlphaValueSpan.innerText = overlayAlphaSliderHTML.value + '%';
            });

            // Set up button listeners
            document.getElementById('saveAccumulationBtn').addEventListener('click', () => {
                accumulatorLayer.save('gaussian_accumulation_pattern.png');
            });
            document.getElementById('clearAccumulationBtn').addEventListener('click', () => {
                accumulatorLayer.background(0); // Reset accumulator layer to black
                console.log('Accumulated pattern cleared.');
            });

            // Load the model
            objectDetector = ml5.objectDetector('cocossd', modelReady);
        }

        function modelReady() {
            console.log('Model loaded.');
            checkboxesContainer.innerHTML = ''; // Clear initial loading message
            video.elt.addEventListener('loadeddata', () => {
                console.log('Video ready. Starting detection...');
                detectObjects();
            });
        }

        function detectObjects() {
            objectDetector.detect(video, gotResults);
        }

        function gotResults(error, results) {
            if (error) {
                console.error(error);
                return;
            }
            detections = results;
            updateLabelCheckboxes(detections);
            detectObjects(); // loop
        }

        function updateLabelCheckboxes(currentDetections) {
            for (let i = 0; i < currentDetections.length; i++) {
                let obj = currentDetections[i];
                if (!(obj.label in labelCheckboxes)) {
                    addLabelCheckbox(obj.label);
                }
            }
        }

        function addLabelCheckbox(label) {
            let labelDiv = document.createElement('label');
            let checkboxInput = document.createElement('input');
            checkboxInput.type = 'checkbox';
            checkboxInput.value = label;
            checkboxInput.id = 'checkbox-' + label.replace(/\s+/g, '-');

            let spanText = document.createElement('span');
            spanText.innerText = label;

            labelDiv.appendChild(checkboxInput);
            labelDiv.appendChild(spanText);
            checkboxesContainer.appendChild(labelDiv);

            labelCheckboxes[label] = checkboxInput;
            selectedLabels[label] = false;

            checkboxInput.addEventListener('change', (event) => {
                selectedLabels[label] = event.target.checked;
                console.log(selectedLabels);
            });
        }

        function draw() {
            // Apply flip transformation for the live video
            push();
            translate(width, 0);
            scale(-1, 1);
            image(video, 0, 0);
            pop();

            // Draw bounding boxes and labels for all detected objects on the main canvas
            for (let i = 0; i < detections.length; i++) {
                let obj = detections[i];
                let cx = obj.x + obj.width / 2;
                let cy = obj.y + obj.height / 2;

                // Adjust coordinates for the flipped video view for drawing overlays
                let displayCx = width - cx;

                stroke(0, 255, 0); // Green bounding box
                strokeWeight(2);
                noFill();
                // Draw rect using original (unflipped) coordinates from ml5, which P5.js's
                // coordinate system is based on for drawing unless transformed.
                // Since we already flipped the *video image*, drawing on top in normal coords is tricky.
                // Instead, we will draw the bounding box *before* flipping, then flip everything.
                // OR, draw the bounding box on the main canvas using transformed coordinates.
                // For simplicity, let's draw them after the flip, using adjusted coords if needed.
                // The bounding box coordinates from ml5 are relative to the *unflipped* video frame.
                // So if we draw on the main canvas (which is not flipped by default for this drawing call),
                // we'd need to manually flip the X-coordinate for display.
                // To avoid complex math for bounding box display, we usually flip the entire canvas, draw, then unflip.
                // However, our current `push`/`pop` only flips the video image.
                // Let's re-think drawing the bounding box: The bounding box `obj.x` etc. refers to the *input* video.
                // If the video is displayed flipped, then the *visual* position of the box also flips.
                // So, `obj.x` would correspond to `width - obj.x - obj.width` in the flipped view.
                // Let's apply transformations to draw boxes correctly on the flipped video.

                // Push and pop again specifically for the bounding box and label drawing
                push();
                translate(width, 0); // Move origin to right
                scale(-1, 1);       // Flip horizontally

                // Now, draw bounding box and text using original obj.x, obj.y as they refer to the flipped content
                // because the canvas transform is active.
                stroke(0, 255, 0); // Green bounding box
                strokeWeight(2);
                noFill();
                rect(obj.x, obj.y, obj.width, obj.height);

                noStroke();
                fill(255); // White text
                textSize(16);
                text(obj.label + ' ' + nfc(obj.confidence * 100, 2) + '%', obj.x + 5, obj.y + 15);

                pop(); // Restore main canvas drawing state

                // Add Gaussian point to accumulatorLayer only for selected objects
                if (selectedLabels[obj.label]) {
                    // Coordinates for adding to the accumulator layer should be consistent
                    // with how the *video is displayed*. Since we are displaying it flipped,
                    // the accumulator layer should also accumulate points based on the flipped view.
                    addGaussianPointToLayer(accumulatorLayer, gaussianKernelData, displayCx, cy);
                    // Draw a small red circle for the current centroid on the main canvas for immediate feedback
                    fill(255, 0, 0);
                    noStroke();
                    ellipse(displayCx, cy, 8, 8);
                }
            }

            // Normalize the accumulator layer's pixels for visualization
            // This normalizes the red channel (which holds our accumulation) to a grayscale image.
            accumulatorLayer.loadPixels();
            let maxAccumulation = 0;
            for (let i = 0; i < accumulatorLayer.pixels.length; i += 4) {
                if (accumulatorLayer.pixels[i] > maxAccumulation) {
                    maxAccumulation = accumulatorLayer.pixels[i];
                }
            }

            if (maxAccumulation > 0) {
                for (let i = 0; i < accumulatorLayer.pixels.length; i += 4) {
                    let normalizedVal = map(accumulatorLayer.pixels[i], 0, maxAccumulation, 0, 255);
                    accumulatorLayer.pixels[i] = normalizedVal; // Red
                    accumulatorLayer.pixels[i+1] = normalizedVal; // Green
                    accumulatorLayer.pixels[i+2] = normalizedVal; // Blue
                    // Use alpha for the accumulated pattern's overall visibility
                    accumulatorLayer.pixels[i+3] = map(normalizedVal, 0, 255, 0, 255 * (parseFloat(overlayAlphaSliderHTML.value) / 100)); // Apply slider alpha
                }
            }
            accumulatorLayer.updatePixels();


            // Overlay the normalized accumulator layer on the main canvas
            // Use blendMode(ADD) for a heat-map like effect, or blendMode(BLEND) for simple overlay
            // blendMode(ADD); // This can make it glow
            image(accumulatorLayer, 0, 0);
            // blendMode(BLEND); // Reset blend mode for other drawings if ADD was used
        }

        // Optional: Keep keyPressed for alternative input, though buttons are primary
        function keyPressed() {
            if (key === 's' || key === 'S') { // Changed from 't' to 's' for consistency with "Save"
                accumulatorLayer.save('gaussian_accumulation_pattern.png');
            }
            if (key === 'c' || key === 'C') {
                accumulatorLayer.background(0); // Reset accumulator layer to black
                console.log('Accumulated pattern cleared.');
            }
        }
    </script>
</body>
</html>
